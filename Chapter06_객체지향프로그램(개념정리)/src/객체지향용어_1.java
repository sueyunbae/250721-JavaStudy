/*
 * 	204p : 1권 => 문법(11장 예외처리)
 * 		   2권 => 구현(라이브러리, 람다식, 어노테이션)
 * 						| 
 * 					  컬렉션(배열대체)
 * 					  입출력
 * 					  데이터베이스 / 네트워크, 쓰레드
 * 								 ------------ 흐름
 * 	1. 객체 지향 프로그램
 * 		1) 관계
 * 			=> 상속 : 재사용 => 기능 변경 필요시
 * 			=> 포함 : 재사용(*****) => 변경할 기능이 없는 경우
 * 			=> 독립적으로 사용
 * 			=> 사용자 정의 클래스보다 라이브러리 상속
 * 			   --------------------------- 오버라이딩
 * 		2) 특징(**********) 면접의 92%
 * 			=> 캡슐화 : 변수관련
 * 					  ------ 인스턴스 변수 / 정적변수
 * 							 ------------------
 * 							 1. 데이터를 보호할 목적
 * 							 2. 경계선
 * 							 3. 메소드와 변수를 한개로 묶어서 외부에서 직접 접근하지 못하게 만든다
 * 								 => getter/setter
 * 									  읽기    쓰기   => lombok
 * 							 4. 접근 지정어 사용법
 * 							 5. 웹에서 주로 캡슐화 사용
 * 			=> 상속
 * 				기존의 변수와 메소드를 재사용 => 확장
 * 				상속 => extends
 * 				단일 상속만 가능
 * 				class A
 * 				class B extends A
 * 					A
 * 					↑ ==> 상속기호
 * 					B
 * 			=> 다형성
 * 				수정(오버라이딩)/추가(오버로딩)
 * 			=> 추상화
 * 				공통적인 특징만 뽑아서 저장
 * 				예) 동물 : 걷는다, 먹는다 ...
 * 					=> 구체화
 * 				추상클래스 / 인터페이스
 * 			예) 게시판(CRUD)
 * 				 목록 출력
 * 				 상세보기
 * 				 글쓰기
 * 				 수정
 * 				 삭제
 * 				 검색
 * 				------------ 파생 : 갤러리게시판, 묻고답하기, 댓글형게시판
 * 								   --------
 * 								   1.목록변경
 * 								   2.글쓰기:업로드
 * 			----------------------------------------------------
 * 			객체지향의 장점
 * 			=> 유지보수가 용이 : 수정 / 추가
 * 			=> 재사용 향상 : 상속 / 인터페이스
 * 			=> 확장성이 좋다 : 새로운 기능 추가
 * 			=> 신뢰성이 좋다 : 기존의 클래스를 확장해서 제작
 * 			=> 코드 가독성이 좋다 
 * 			
 * 		---------------------------------------------------------
 * 		자바에서 객체 지향
 * 		-------------
 * 		 => 객체 생명주기
 * 		class => 설계 => 메모리에 저장  =>  필요시에 사용  =>  메모리 소멸
 * 		------------ 클래스명 객체;        객체.메소드       객체=null
 * 					 객체=new 클래스명();  객체.변수
 * 					 클래스명 객체=new 클래스명()
 * 		class 설계
 * 		---------
 * 		구조
 * 		class ClassName
 * 		{
 * 			-----------
 * 			 사용할 데이터 => 자판기(음료수, 동전)
 * 			  => 변수
 *			-----------
 *			 데이터를 다시 추가/감소
 *			 초기값 : 생성자
 *			-----------
 *			 동작
 *			 메소드
 *			-----------
 *		} 
 *
 *		변수 => 저장위치, 선언위치, 생명주기
 *		1) 지역변수
 *			선언위치 : 메소드, 생성자, 블록내부에 선언
 *								------ {}
 *			** 반드시 초기값을 부여 => 사용
 *			저장위치 : 스택 => 관리를 메모리 자체
 *						   ------------
 *			생명주기 : {}안에서만 사용이 가능 => 블록을 벗어나면 자동 회수
 *			class A
 *			{
 *				void display()
 *				{
 *					// 지역변수 선언 위치
 *				}
 *				A()
 *				{
 *					// 지역변수 선언 위치
 *				}
 *			}
 *		2) 인스턴스변수	
 *			클래스내부 블록에 선언 => 클래스 위나 아래에 선언이 가능하다
 *			객체 생성시에 메모리에 저장 => new를 사용할 때 메모리에 저장
 *								   --- 새로운 메모리가 생성
 *			초기값은 지정하지 않는 경우 => 자동으로 기본값이 설정된다
 *			int=>0, double=>0.0, String(클래스)=>null
 *			=> null은 주소를 가지고 있지 않는 경우
 *			=> 실제로 클래스의 멤버변수
 *			=> 클래스 전체 사용 / 다른 클래스에서 사용이 가능
 *		3) 정적변수
 *			모든 객체가 공유하는 변수
 *			*** 구분(따로 저장되는 변수, 한개를 가지고 사용)
 *			*** 벤치마킹 
 *			컴파일시에 자동 생성
 *			프로그램 종료시까지 메모리 유지	
 *		----------------------------------------------
 *		핵심)
 *			지역변수 : 메소드 안에서 사용, 초기값을 반드시 부여
 *			인스턴스변수 : 객체마다 따로 메모리가 생성, 기본값이 있다 
 *			-------- 객체.변수
 *			정적변수 : 클래스변수, 공유변수
 *					------- 클래스명.변수
 *							=> 모든 객체가 데이터를 공유 => static
 *							=> 데이터 묶음, 오라클에 저장된 데이터
 *			*** 초기화 여부
 *				지역변수 : 필수, 직접 대입, 연산 결과 대입, 기본값은 없다
 *				인스턴스변수 : 선택, 선언시 대입, 생성자에서 대입, 기본값이 있다
 *				정적변수 : 선택, 선언시 대입, 초기화 블록, 기본값이 있다
 *			*** 초기화 방법
 *				1) 선언과 동시에 초기화 : 명시적 초기화 => 고정(한가지)
 *				2) 생성자를 통해서 초기화 => 여러가지 값을 지정
 *					=> 사용자로부터 값을 받아서 저장이 가능
 *					=> 매개변수
 *				3) 초기화 블록 => 고정(한가지)
 *				   ----------------------
 *					인스턴스 => {}
 *					정적변수 => static {}
 *				   ---------------------- 파일 읽기/데이터베이스/쿠키,세션
 *		저장되는 순서
 *		---------
 *		  기본값 ======= 0
 *		  명시적 초기값 == 1
 *		  정적블록 ====== 2
 *		  인스턴스블록 === 3
 *		  생성자 ======= 5
 *		----------------- 보통 사용
 *		  인스턴스 변수 : 반드시 생성자를 호출 => 생성자 초기화
 *		  정적 변수 : 자동 저장 => static {}
 *	  *** 변수는 초기값이 있어야 메모리에 저장이 가능 => 프로그램에서 사용이 가능
 *	  
 *	  생성자
 *		=> 객체가 생성될 때 호출되는 메소드 형태의 코드 블록
 *						  ------- 
 *		=> 역할 : 인스턴스변수에 대한 초기값 대입 (초기화 함수)
 *		=> 시작과 동시에 처리해야 되는 기능 설정
 *			** 자동 로그인/아이디 저장을 전송
 *			** 쿠키를 읽어 온다 => 장바구니, 최근 방문
 *			** 화면 UI => 레이아웃
 *		=> 특징
 *			클래스명과 동일 
 *			리턴형이 없다 => void도 리턴형
 *			오버로딩 지원
 *			----- 같은 이름의 메소드로 새로운 기능 제작
 *			 | 변수에 대한 초기값을 변경 => 매개변수
 *			** 모든 클래스는 생성자가 한개이상이 반드시 필요하다
 *				=> 생성자가 없는 경우 컴파일러가 자동으로 기본생성자 추가
 *				=> 기본 생성자 => 매개변수가 없는 생성자
 *			=> 생성자의 종류
 *				기본생성자(디폴트 생성자) => 자동 추가가 될 수 있다
 *				 => 시작과 동시에 처리해야 되는 기능 설정
 *			  	매개변수가 있는 생성자
 *				=> 객체마다 다른 데이터를 저장하고 싶은 경우
 *			=> 변수
 *				기본형(실제값) = int a, double d... 
 *				-----
 *				배열 : 같은 데이터형
 *				클래스 : 다른 관련된 데이터형
 *				----- 참조형(주소값)
 *			=> this() / super()
 *			   this() => 클래스 자신의 생성자를 호출
 *						 호출되는 위치는 반드시 생성자에서 호출
 *						 생성자의 첫줄에서만 사용이 가능
 *			   super() => 상속 내린 클래스의 생성자 호출
 *						  호출하는 위치는 반드시 생성자에서 호출
 *						  생성자의 첫줄에서 사용이 가능
 * */
class Student
{
	int hakbun;
	String name;
	Student() {
		hakbun=1;
		name="홍길동";
	}
	Student(int h) {
		this(); //Student()
		hakbun=h;
	}
	Student(String n) {
		this(10); //Student(int h)
		name=n;
	}
	Student(int h,String n) {
		hakbun=h;
		name=n;
	}//오버로딩
}

// 매개변수나 인스턴스 변수에 중복이 있는 경우
class Car
{
	String model;
	String color;
	int maxSpeed;
	
	Car(String m)
	{
		//model=m;
		//color="검정색";
		//maxSpeed=300;
		this(m,"검정색",300);
	}
	Car(String m,String c)
	{
		//model=m;
		//color=c;
		//maxSpeed=250;
		this(m,c,250); //다른 생성자 호출
	}
	Car(String m,String c,int ms)
	{
		model=m;
		color=c;
		maxSpeed=ms;
	}
	
}
public class 객체지향용어_1 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Student std=new Student();
		System.out.println("std.hakbun="+std.hakbun);
		System.out.println("std.name="+std.name);
		

		Student std2=new Student(5);
		System.out.println("std2.hakbun="+std2.hakbun);
		System.out.println("std2.name="+std2.name);
		

		Student std3=new Student("심청이");
		System.out.println("std3.hakbun="+std3.hakbun);
		System.out.println("std3.name="+std3.name);
		
		Student std4=new Student(7,"이순신");
		System.out.println("std4.hakbun="+std4.hakbun);
		System.out.println("std4.name="+std4.name);
		
		Car c1=new Car("현대자동차");
		System.out.println("c1.model="+c1.model);
		System.out.println("c1.color="+c1.color);
		System.out.println("c1.speed="+c1.maxSpeed);
		
		Car c2=new Car("기아자동차","회색");
		System.out.println("c2.model="+c2.model);
		System.out.println("c2.color="+c2.color);
		System.out.println("c2.speed="+c2.maxSpeed);
				
	}

}
